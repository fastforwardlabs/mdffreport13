## Landscape

Causality spans a broad area of topics, including using causal insights to improve machine learning methods, adapting it for high-dimensional datasets and applying them for better data-driven decision making in real-world contexts. We also discussed in Chapter 3 how the collected data is rarely an accurate reflection of the population, and hence may fail to generalize in different environments or new datasets. Methods based on invariance show promise in addressing out-of-distribution generalization.

### Use Cases

As we demonstrated in the [Prototype](#prototype) Chapter, Invariant Risk Minimization is particularly well suited to image problems in diverse physical environments. However, an environment need not mean only the scenery in an image, and when it does, it need not be fixed to a single value. Here we suggest some applications in and beyond computer vision.

#### Healthcare

In clinical imaging settings, radiologists manually annotate tissues, abnormalities, and pathologies of In healthcare, medical images have to be manually annotated by radiologists to identify abnormalities. These annotated images are then used to train and build diagnostic models. Oftentimes the devices like MRI scanners that generate these medical images exhibit some kind of variation.^[This example is given in [An introduction to domain adaptation and transfer learning](https://arxiv.org/abs/1812.11806), and an empirical study using transfer learning was reported in [Transfer Learning Improves Supervised Image Segmentation Across Imaging Protocols](https://ieeexplore.ieee.org/document/6945865)] That is, the images that are generated by one MRI scanner could be systematically different from another for the same patient, due to mechanical configurations, vendor differences or any number of other reasons. As such a diagnostic model that was built on the images generated by an old MRI scanner may perform poorly when tested on the images generated by a new scanner. One way to solve this problem is to have the radiologist annotate the images generated by the new scanner and then re-train the model. But that could be expensive and time consuming. Plus, this isn’t a permanent solution, everytime there's a new scanner or changes to the configuration one will have to go back to making the existing model work with a new set of images.

A diagnostic model based on invariant prediction that treats scanners as environments could be immune to these noisy device variations and change its decisions accordingly. This could save the time and money needed to annotate images from the new scanner.

#### Robotics

![figure: robot](figures/ff13-26.png)

Autonomous systems need to detect and adapt to different environments. These systems rely on sophisticated sensors, cameras and large amounts of labeled and diverse real-world datasets which are difficult to acquire. Take for example, the task of autonomously following a man-made trail that is traversed by hikers or mountain bikers. This is a mostly unsolved task for robotics but yet an important one for applications like search and rescue.^[[A Machine Learning Approach to Visual Perception of Forest Trails for Mobile Robots](http://rpg.ifi.uzh.ch/docs/RAL16_Giusti.pdf)]

While many robot types, such as the quadrupedal robot, can be efficient at locomotion, successfully navigating real-world forest trails is hard. Apart from the mechanics of the problem, perceiving real-world trails is difficult. The appearance of the wilderness area may vary a lot depending on the location, unpaved roads generally have less structure and blend with the surrounding grass areas, vegetation and such, and trails change over time. It would be impossible to have a comprehensive dataset of all trails, in all weather and lighting conditions.

In such cases, a possible solution is to cast the trail perception problem as an image classification task and adopt an invariance based approach that operates directly on the image’s raw pixel values. Successful application could allow for out-of-distribution generalization to new trails, since the features learned are more transferable than environment-specific signals. Naturally, similar ideas are relevant for autonomous vehicles in urban areas.

#### Activity recognition systems

Smart devices (phones, watches, fitness trackers) carry a large array of sensors: accelerometers, gyroscopes, magnetometers, barometers, ambient lights sensors and many more. Categorizing this data by the activity being performed at the time of recording - such as sitting, standing or swimming - has allowed for the development of machine learning based human-activity recognition systems. Correctly predicting a wearer’s activity enables a host of contextual applications, in particular in (but not restricted to) the health and wellness space.^[[Scaling Human Activity Recognition via Deep Learning-based Domain Adaptation](https://ieeexplore.ieee.org/document/8444585) outlines the problem and some applications in this space.]

Unfortunately, it is hard to satisfactorily model this data due to the diversity exhibited in the real world. A single individual can perform a given activity slightly differently day-to-day, the device may be unusually placed, or held or worn in a variety of orientations. Of course, different users are physically diverse, and devices have intrinsic differences in their sensors and systems. This also means that we either need a labelled dataset that captures the activity for each user and device (which is prohibitively expensive) or another way of identifying attributes that generalize better. Methods based on invariance could be particularly useful and well suited in this scenario, capturing the essence of “sitting”, rather than the particular sensor activations for a particular user sitting on a particular chair.

#### Natural language processing

![figure: different types of text](figures/ff13-25.png)

Invariant prediction approaches are of course not restricted exclusively to image problems. In natural language processing, texts from different publication platforms are tricky to analyze due to different contexts, vocabularies and differences between how authors express themselves. For instance, financial news articles use a vocabulary and tone that differs from culture or society articles. The former is likely terse, whereas the latter may have an entertaining or personal tone. Similarly, online product reviews are linguistically different from tweets. Sentiment classification also relies heavily on context; different words are used to express whether someone likes a book versus an electronic gadget.

Two recent papers, [An Empirical Study of Invariant Risk Minimization](https://arxiv.org/abs/2004.05007) and [Invariant Rationalization](https://arxiv.org/abs/2003.09772), apply the idea of IRM to a sentiment classification task, and find it improves out of distribution generalization. In particular, invariance acts to remove spurious reliance on single words which correlate highly with the target. Like images, text corpora form very high dimensional datasets (there are many possible words!), making spurious correlations extremely unlikely to be noticed “manually”. As such, invariance based approaches are especially promising here.

#### Recommender systems

![figure: recommender system](figures/ff13-24.png)

Recommendation systems are algorithms designed to present relevant items to the users on the web, for example, suggesting which movie to watch, a book to read or a product to buy. As such, making good recommendations is an important problem. The problem is one of making a relevant recommendation for a user based on a record of their historical activities, from which we must infer their preferences.

The training data is either explicit (e.g. a rating a user left on a book) or implicit (e.g. linger time on a webpage, or click data). There is a well known exposure problem in recommender systems. A user simply cannot click on an item they have not been presented with. Modeling the data without accounting for this is akin to the assumption of independent and identically distributed data, and is false: users do not select items randomly and independently of one another. For instance, a user may choose between two competing movies to watch, rather than selecting whether to watch each independently.

ReySys are a classic application for causality, which allows us to correct for this exposure bias by treating the selection of items to present to a user as an intervention. Applying causal approaches to recommendation naturally improves generalization to new data,^[See [Causal Inference for Recommendation](http://www.its.caltech.edu/~fehardt/UAI2016WS/papers/Liang.pdf) and [The Deconfounded Recommender: A Causal Inference Approach to Recommendation](https://arxiv.org/abs/1808.06581).] and it seems likely that methods using invariant prediction could enhance this.

### Tools

The invariance-based approaches to causality we have discussed do not require dedicated tooling - ICP and IRM are procedures that could be implemented with general purpose machine learning frameworks.

Nonetheless, the authors of the ICP papers ^[[Causal inference using invariant prediction: identification and confidence intervals](https://arxiv.org/abs/1501.01332) and [Invariant Causal Prediction for Nonlinear Models](https://arxiv.org/abs/1706.08576).] provide corresponding R packages: [InvariantCausalPrediction](https://cran.r-project.org/web/packages/InvariantCausalPrediction/index.html) and [nonlinearICP](https://cran.r-project.org/web/packages/nonlinearICP/index.html). The packages make the techniques easy to use, and include additional utilities, such as dedicated plots for confidence intervals on causal coefficients. We are not aware of a package for IRM, but the authors have provided a [code repository](http://github.com/facebookresearch/InvariantRiskMinimization/) which reproduces the paper results.

Below, we list a handful of open source projects that aid in traditional, SCM-based causal inference.

#### DoWhy

Microsoft Research is developing the [DoWhy](https://microsoft.github.io/dowhy/) python library for causal inference, incorporating elements of both causal graphical models and potential outcomes. The library is oriented around pandas DataFrames, and as such fits easily into a Python data analysis workflow. In particular DoWhy makes a separation between four stages of causal inference:

1. Modeling - defining a causal graph, or else the assumptions necessary for a potential outcomes approach (the common causes of the treatment and the outcome variable).
2. Identification - identifying the expression it is necessary to evaluate, in terms of conditional probability distributions.
3. Estimation - estimating the treatment effect. There are many estimation methods available in DoWhy, including machine learning based methods from another of Microsoft's causal libraries: [EconML](https://github.com/microsoft/EconML)
4. Refutation - assessing the robustness of the conclusion. Given the reliance of causal inference on modeling assumptions, it is especially important to find ways to test our conclusions. DoWhy provides several methods for this, such as introducing a dummy common cause or replacing the treatment with a random placebo.

In addition to the above, DoWhy includes a novel algorithm, the "do-sampler." In much of causal inference, the quantity of interest is a single number, for instance, the difference in the outcome variable when a binary treatment variable is applied ("what is the average causal effect of smoking on cancer incidence?"). The do-sampler extends the pandas DataFrame API directly, and moves beyond calculating causal effects to allow sampling from the full interventional distribution. Having done so, we can then compute arbitrary statistics under this intervention. The do-sampler is new, but provides a very promising direction for further research, and a potential avenue to making causal inference accessible to many more data science practitioners.

#### CausalDiscoveryToolbox

The [Causal Discovery Toolbox](https://fentechsolutions.github.io/CausalDiscoveryToolbox/html/index.html) provides implementations of many algorithms designed for causal discovery - attempting to recover the full causal graph from observational data alone. There are many approaches to causal discovery, and the library is relatively comprehensive, including both algorithms pairwise causal discovery (inferring the direction of causation between a pair of variables), graph skeleton creation (creating an undirected graph of potential causal relationships), and full graphical causal model discovery.

Discovery of entire causal graphs does not yet appear mature enough that we can naively trust it’s conclusions about the causal structure of a problem. This makes sense given the difficulty of the task! Inferring the whole causal structure from only observational data is about the hardest imaginable problem we could face with data!

#### CausalNex

[CausalNex](https://causalnex.readthedocs.io/en/latest/) is a very recently released (at time of writing) toolkit to help data scientists do causal reasoning, by QuantumBlack. It provides both a graph structure learning component, to help build the causal graph, and tools to fit that graph as a Bayesian network.

The structure learning component is an implementation of [DAGs with NOTEARS](https://arxiv.org/abs/1803.01422), an algorithm that casts structure learning as a continuous optimization problem. In its simplest form, it assumes linear relationships between variables (but unlike some causal discovery methods, does not assume Gaussian noise). Further, the algorithm assumes that all variables are observed (ie. there is data for all variables). Unfortunately, this is rarely the case in causal problems.

Within these limitations, the algorithm is performant, and allows the user to specify hard constraints (such as "these variables cannot be child nodes", or "there is no causal relationship between these two variables"). This facilitates directly encoding domain knowledge into the graph, and using the structure learning component as an aid in places where the causal connection is not known.

#### Pyro

Uber's [Pyro](http://pyro.ai/) probabilistic programming library is primarily intended for implementing deep probabilistic models and fitting them with variational inference. However, in addition to tools for conditioning on observed data, the library implements a do operation to force a variable to take a certain distribution. This allows simulating from interventional distributions, provided the structural causal model (including equations) is known. The intersection of probabilistic programming with causal inference is nascent, but promising!